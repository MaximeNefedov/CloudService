# Дипломный проект "Облачное хранилище"

## Введение
Данная работа выполнена в соответствии с требованиями: https://github.com/netology-code/jd-homeworks/blob/master/diploma/cloudservice.md

Проект является backend составляющей restful-сервиса облачного хранилища.

Основной функционал:
1) Хранение файлов в облаке
2) Изменение файлов
3) Удаление файлов
4) Добавление файлов
5) Передача файлов от сервера на клиент

Приложение использует реляционную базу данных PostgreSQL для хранения файлов и данных о пользователях

Ссылка на frontend: https://github.com/netology-code/jd-homeworks/tree/master/diploma/netology-diplom-frontend
## Инструкция для использования
Frontend - приложение работает на порту 8080,
backend на порту 8888, а СУБД PostgreSQL на 5432.
Запустить весь сервис целиком можно с помощью утилиты docker-compose: https://github.com/MaximeNefedov/CloudService/blob/master/CloudServiceBackend/docker-compose.yml
## Описание работы backend - сервиса

### Процесс аутентификации
Для получения JWT - токена, который позволит осуществлять взаимодействие с сервером, front-end приложение отправляет POST - запрос на back-end сервис на endpoint /login. В теле запроса указываются логин и пароль пользователя.
Запрос попадает на фильтр  JwtUsernamePasswordAuthenticationFilter, который в методе attemptAuthentication извлекает из запроса данные, необходимые для аутентификации и с помощью AuthenticationManager осуществляет процесс аутентификации: используя метод loadUserByUsername
интерфейса UserDetailsService (имплементация - класс CustomUserDetailsService), производится попытка загрузить пользователя из базы данных по логину, если такого пользователя нет, то на front - end отправляется ответ со статусом 403 и сообщением "Authenication error". Если пользователь найден и хеши паролей совпадают, то пользователь помещается в SpringSecurityContext. Далее вызывается метод  successfulAuthentication, в котором создается JWT - токен, он подписывается секретным ключом и отправляется в качестве ответа на front. 
Полученный JWT - токен будет помещен в заголовок "auth-token" каждого запроса к серверу.
За проверку наличия и валидность этого заголовка отвечает класс JwtTokenVerifier, который реализует интерфейс OncePerRequestFilter. Этот класс имеет всего один метод doFilterInternal, в котором сначала с помощью утилитарного класса JwtTokenHandler осуществляется проверка наличия заголовка "auth-token". Если проверка не пройдена, то запрос передается дальше по цепочке фильтров дальше, в конечном итоге front получит ответ со статусом 403, если же заголовок валиден, то с помощью все того же класса JwtTokenHandler проверяется подлинность полученного токена. Если проверка пройдена, то считается, что запрос прошел процесс аутентификации.
### Ролевая политика безопасности
Каждый пользователь в системе может иметь одну или несколько ролей (ADMIN, USER), получив какую-то роль пользователю транзитивно назначаются определенные authorities (READ, WRITE, DELETE). Наличие authority проверяется в методах контроллера backend - приложения

### Запрос всех файлов
Backend - приложение предоставляет возможность указывать в query-параметрах GET-запроса количество файлов, которое будет возращено для конкретного пользователя. Указывать число, меньше 1 запрещено. Если у пользователя отсутствуют файлы, то возвращается пустой список.

Общее представение работы системы на примере запроса списка файлов:
![image1](https://raw.githubusercontent.com/MaximeNefedov/CloudService/repository_layer/screens/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%20%D0%B2%D1%81%D0%B5%D1%85%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2.png)

### Сохранение файла
FileController устанавливает следующие ограничения на сохранение файла: 
1) Тело POST - запроса не должно быть пустым и оно инкапсулируется объектом MultipartFile
2) Пользователь должен иметь authority "WRITE"
3) Имя файла, передаваемое в query-параметрах, проверяется на null и на наличие расширения. Если расширение указано, то оно валидируется за счет обращения к словарю поддерживаемых типов файлов.

Cхема работы метода сервисного слоя, отвечающего за сохранение файла:
![image2](https://raw.githubusercontent.com/MaximeNefedov/CloudService/repository_layer/screens/%D1%81%D1%85%D0%B5%D0%BC%D0%B0%20%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%84%D0%B0%D0%B9%D0%BB%D0%B0.png)

### Изменение имени файла
FileController осуществляет проверку имени файла, подлежащего изменению, а также проверяет валидность нового названия.
Изменение имени файла осуществляется в методе сервисного слоя editFilename. 
Класс FileServiceImpl считает хеш файла, и проверяет, есть ли в базе данных файл с такими хешем. Если файл найден, то вычисляется новый хеш по новому имени и запись в базе данных изменяется.
Если файл не был найден, то выбрасывается соответствующее исключение

### Удаление файла 
FileController также проверяет валидность имени файла и делегирует работу дальше. 
FileServiceImpl в методе deleteFile также считает хеш файла и, если файл был найден в базе данных, устанавливает статус DELETED и указывает время удаления файла. Это может быть полезно в дальнейшем, чтобы условный администратор базы данных мог вести учет удаленных файлов и чистить БД во время профилактических работ. 

### Загрузка файла с backend
За скачивание файла из базы данных отвечает метод downloadFile. По посчитанному хеш-идентификатору ищется запись в БД. Если совпадение найдено, то в качестве ответа от сервера пользователю отправляется указанный файл. В противном слоучае, слой сервиса выбрасывает исключение.