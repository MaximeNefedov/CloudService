# Дипломный проект "Облачное хранилище"

## Введение
## Инструкция для использования
## Описание работы backend - сервиса

### Процесс аутентификации
Для получения JWT - токена, который позволит осуществлять взаимодействие с сервером, front-end приложение отправляет POST - запрос на back-end сервис на endpoint /login. В теле запроса указываются логин и пароль пользователя.
Запрос попадает на фильтр  JwtUsernamePasswordAuthenticationFilter, который в методе attemptAuthentication извлекает из запроса данные, необходимые для аутентификации и с помощью AuthenticationManager осуществляет процесс аутентификации: используя метод loadUserByUsername
интерфейса UserDetailsService (имплементация - класс CustomUserDetailsService), производится попытка загрузить пользователя из базы данных по логину, если такого пользователя нет, то на front - end отправляется ответ со статусом 403 и сообщением "Authenication error". Если пользователь найден и хеши паролей совпадают, то пользователь помещается в SpringSecurityContext. Далее вызывается метод  successfulAuthentication, в котором создается JWT - токен, он подписывается секретным ключом и отправляется в качестве ответа на front. 
Полученный JWT - токен будет помещен в заголовок "auth-token" каждого запроса к серверу.
За проверку наличия и валидность этого заголовка отвечает класс JwtTokenVerifier, который реализует интерфейс OncePerRequestFilter. Этот класс имеет всего один метод doFilterInternal, в котором сначала с помощью утилитарного класса JwtTokenHandler осуществляется проверка наличия заголовка "auth-token". Если проверка не пройдена, то запрос передается дальше по цепочке фильтров дальше, в конечном итоге front получит ответ со статусом 403, если же заголовок валиден, то с помощью все того же класса JwtTokenHandler проверяется подлинность полученного токена. Если проверка пройдена, то считается, что запрос прошел процесс аутентификации.
### Ролевая политика безопасности
Каждый пользователь в системе может иметь одну или несколько ролей (ADMIN, USER), получив какую-то роль пользователю транзитивно назначаются определенные authorities (READ, WRITE, DELETE). Наличие authority проверяется в методах контроллера backend - приложения

### FileHandler
Основное взаимодействие с базой данных осуществляет FIleHandler, декларирующий следующие методы: uploadToDb, deleteFileFromDb, editFilenameInDb, getAllFiles, downloadFile. По умолчанию используется реализация DefaultFileHandler.
Поскольку файлы в базе данных индентифицируются по посчитанному хешу (имя файла + логин пользователя, тип контента(content type в http запросе)), то DefaultFileHandler умеет распознавать тип контента по расширению файла. Для этого он использует внешний файл mime_types.csv, в котором данные хранятся в виде таблицы (тип контента - расширение). Этот функционал нужнен для того, чтобы быстро посчитать хеш конкретного файла, используя принятые логин и имя файла.
### Запрос всех файлов
Backend - приложение предоставляет возможность указывать в query параметрах GET - запроса количество файлов, которое будет возращено для конкретного пользователя. Указывать число, меньше 0 запрещено. Если у пользователя отсутсвуют файлы, то возвращается пустой список.

Cхема работы системы:
![image1](https://raw.githubusercontent.com/MaximeNefedov/CloudService/master/CloudServiceBackend/screens/getAllFiles.png)
### Сохранение файла
FileController устанавливает следующие ограничения на сохранение файла: 
1) Тело POST - запроса не должно быть пустым и оно инкапсулируется объектом MultipartFile
2) Пользователь должен иметь authority "WRITE"

За добавление файла в базу данных отвечает метод uploadToDb класса DefaultFileHandler, принимающий в параметрах объекты классов MultipartFile (сам файл) и User (нужен для того, чтобы указать владельца файла в таблице базы данных). 
DefaultFileHandler вычислит content type файла, а затем его хеш. Далее помощью DBHandler проверит, есть ли уже в базе данных файл, имеющий такой же хеш и имеет ли он статус DELETED.
Если условие выполнено, то осуществится байтовая проверка тел файлов. Если тела файлов равны, то файл, который хочет сохранить пользователь можно рассматривать, как файл, подлежащий восстановлению. Следовательно в базе данных будут произведены следующие изменения: установлен флаг ACTIVE у файла, удалено поле removal time, и обновлено поле change time.
Но если тела файлов не равны, то для того, чтобы не спровоцировать SQLException (запрет на дубликаты файлов, ибо хеши равны), то DBHandler удалит помеченный как DELETED файл из базы данных.

Если же файла с посчитанным хешем нет в базе данных, то будет создан объект UploadedFile, включающий в себя: имя файла, тип контента, размер, время изменения, тело файла, поле типа User (владелец файла), хеш файла и статус файла ACTIVE.

Cхема работы системы:
![image2](https://raw.githubusercontent.com/MaximeNefedov/CloudService/master/CloudServiceBackend/screens/saveFile.png)

### Изменение имени файла
FileController осуществляет проверку имени файла, подлежащего изменению, а также проверяет валидность нового названия по единому правилу: название файла должно состоять из букв, цифр или символа "_", а также иметь какое-то расширение.
Изменение имени файла осуществляется в методе editFilenameInDb класса DefaultFileHandler. 
DefaultFileHandler считает хеш файла, и проверяет, есть ли в базе данных файл с такими хешем. Если файл найден, то высчитывается новый хеш по новому имени и запись в базе данных изменяется.
Если файл не был найден, то DefaultFileHandler возвращает false. DefaultCloudServiceFileRepository, который вызвал метод у DefaultFileHandler реагирует на неудачную попытку изменения имени файла и выбрасывает соответствующее исключение

Cхема работы системы:
![image3](https://raw.githubusercontent.com/MaximeNefedov/CloudService/master/CloudServiceBackend/screens/editFileName.png)

### Удаление файла 
FileController также проверяет валидность имени файла и делегирует работу дальше. 
DefaultFileHandler в методе deleteFileFromDb также считает хеш файла и, если файл был найден в базе данных, устанавливает статус DELETED, указывает время удаления файла и возвращает true. Это может быть полезно в дальнейшем, чтобы условный администратор базы данных мог вести учет удаленных файлов и чистить БД во время профилактических работ. 
Если же метод deleteFileFromDb вернет false, то DefaultCloudServiceFileRepository выбросит соответствующее исключение

Cхема работы системы:
![image4](https://raw.githubusercontent.com/MaximeNefedov/CloudService/master/CloudServiceBackend/screens/deleteFile.png)

### Загрузка файла с backend
Процесс валидации имени файла аналогичен тому, который был описан выше.
За скачивание файла из базы данных отвечает метод downloadFile класса DefaultFileHandler. Также считается хеш, по которому ищется совпадение в базе данных. Метод возращает true или false в зависимости от того, был ли найден файл. Если возвращается false, то DefaultCloudServiceFileRepository выбросит соответствующее исключение

Cхема работы системы:
![image5](https://raw.githubusercontent.com/MaximeNefedov/CloudService/master/CloudServiceBackend/screens/downloadFile.png)

### LoggingAspect
Согласно принципу single responsibility, каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Следовательно, например, компонент FileService должен отвечать за бизнес логику, но, если при этом он будет также осуществлять логгирование, то этот принцип будет нарушен. Вдобавок, если появится необходимость кардинально изменить логику логгирования, то придется изменять код практически в каждом классе программы. Класс LoggingAspect использует предоставляемые Spring воможности АОП подхода для процесса логгирования, которые позволяют описать общую для нескольких классов логику в одном месте.
